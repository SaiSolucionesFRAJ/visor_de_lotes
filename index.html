<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de Lotes de Urbanización - Sistema de Ventas</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --sai-dark-blue: #1a2b4a;
            --sai-blue: #2c3e5f;
            --sai-purple: #7b68ee;
            --sai-light-purple: #9d8df7;
            --sai-orange: #ff8c42;
            --sai-light-orange: #ffab73;
            --sai-white: #ffffff;
            --sai-light-gray: #f8f9fa;
            --sai-gray: #e9ecef;
            --sai-border: #dee2e6;
            --sai-text: #2c3e50;
            --sai-text-light: #6c757d;
            --shadow-sm: 0 2px 4px rgba(26, 43, 74, 0.08);
            --shadow-md: 0 4px 12px rgba(26, 43, 74, 0.12);
            --shadow-lg: 0 8px 24px rgba(26, 43, 74, 0.16);
            --available-color: #10b981;
            --reserved-color: #f59e0b;
            --sold-color: #ef4444;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, #f5f7fa 0%, #e9ecef 100%);
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 380px;
            grid-template-rows: 70px 1fr;
            height: 100vh;
            gap: 0;
        }

        header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, var(--sai-dark-blue) 0%, var(--sai-blue) 100%);
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 30px;
            z-index: 1000;
            position: relative;
        }

        header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--sai-purple) 0%, var(--sai-orange) 100%);
        }

        .logo {
            font-size: 22px;
            font-weight: 700;
            color: var(--sai-white);
            display: flex;
            align-items: center;
            gap: 12px;
            letter-spacing: -0.5px;
        }

        .logo img {
            height: 36px;
            width: auto;
            filter: drop-shadow(0 2px 4px rgba(255, 140, 66, 0.3));
        }

        .logo-text {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
        }

        .logo-main {
            font-size: 18px;
        }

        .logo-sub {
            font-size: 11px;
            font-weight: 400;
            color: var(--sai-light-orange);
            letter-spacing: 0.5px;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-left: auto;
        }

        .view-toggle {
            display: flex;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 25px;
            overflow: hidden;
            padding: 4px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .view-button {
            padding: 10px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            color: rgba(255, 255, 255, 0.8);
            border-radius: 20px;
            letter-spacing: 0.3px;
        }

        .view-button:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
        }

        .view-button.active {
            background: linear-gradient(135deg, var(--sai-orange) 0%, var(--sai-light-orange) 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(255, 140, 66, 0.4);
        }

        .map-tools {
            display: flex;
            gap: 8px;
        }

        .tool-button {
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            color: white;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .tool-button:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .tool-button.active {
            background: linear-gradient(135deg, var(--sai-purple) 0%, var(--sai-light-purple) 100%);
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(123, 104, 238, 0.4);
        }

        main {
            position: relative;
            background-color: #fff;
            overflow: hidden;
            border-radius: 20px 0 0 0;
            box-shadow: var(--shadow-md);
        }

        #map-viewer {
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        .map-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .coordinates {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--sai-dark-blue) 0%, var(--sai-blue) 100%);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .legend {
            position: absolute;
            top: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            min-width: 160px;
        }

        .legend-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--sai-dark-blue);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 11px;
            color: var(--sai-text);
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 2px solid white;
            box-shadow: var(--shadow-sm);
        }

        .legend-color.available {
            background: var(--available-color);
        }

        .legend-color.reserved {
            background: var(--reserved-color);
        }

        .legend-color.sold {
            background: var(--sold-color);
        }

        aside {
            display: flex;
            flex-direction: column;
            background: white;
            border-left: 1px solid var(--sai-border);
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        .sidebar-content {
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 5px;
            scrollbar-width: thin;
            scrollbar-color: var(--sai-purple) transparent;
        }

        .sidebar-content::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar-content::-webkit-scrollbar-track {
            background: transparent;
            margin: 5px 0;
        }

        .sidebar-content::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--sai-purple) 0%, var(--sai-light-purple) 100%);
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .sidebar-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, var(--sai-light-purple) 0%, var(--sai-purple) 100%);
        }

        .panel {
            padding: 20px;
            border-bottom: 2px solid var(--sai-gray);
            min-height: min-content;
        }

        .panel:last-child {
            border-bottom: none;
        }

        .panel-title {
            font-size: 15px;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--sai-dark-blue);
            display: flex;
            align-items: center;
            gap: 10px;
            position: sticky;
            top: 0;
            background: white;
            padding: 8px 0;
            z-index: 10;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .panel-title i {
            color: var(--sai-orange);
            font-size: 18px;
        }

        .control-button {
            width: 100%;
            padding: 14px 20px;
            margin-bottom: 12px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            letter-spacing: 0.3px;
            position: relative;
            overflow: hidden;
        }

        .control-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .control-button:hover::before {
            width: 300px;
            height: 300px;
        }

        .control-button i {
            position: relative;
            z-index: 1;
        }

        .control-button span {
            position: relative;
            z-index: 1;
        }

        .control-button.primary {
            background: linear-gradient(135deg, var(--sai-purple) 0%, var(--sai-light-purple) 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(123, 104, 238, 0.3);
        }

        .control-button.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(123, 104, 238, 0.4);
        }

        .control-button.secondary {
            background: var(--sai-light-gray);
            color: var(--sai-text);
            border: 2px solid var(--sai-border);
        }

        .control-button.secondary:hover {
            background: var(--sai-gray);
            border-color: var(--sai-purple);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .control-button.tertiary {
            background: linear-gradient(135deg, var(--sai-orange) 0%, var(--sai-light-orange) 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(255, 140, 66, 0.3);
        }

        .control-button.tertiary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 140, 66, 0.4);
        }

        .control-button.success {
            background: linear-gradient(135deg, var(--available-color) 0%, #059669 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .control-button.success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .control-button.warning {
            background: linear-gradient(135deg, var(--reserved-color) 0%, #d97706 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        }

        .control-button.danger {
            background: linear-gradient(135deg, var(--sold-color) 0%, #dc2626 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        .lot-data-panel {
            background: white;
            border-radius: 14px;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            overflow: hidden;
            transition: all 0.3s ease;
            border: 1px solid var(--sai-border);
            margin-bottom: 10px;
            width: 100%;
        }

        .lot-data-panel:hover {
            box-shadow: 0 10px 20px rgba(26, 43, 74, 0.2);
            transform: translateY(-3px);
        }

        .lot-data-header {
            background: linear-gradient(135deg, var(--sai-purple) 0%, var(--sai-light-purple) 100%);
            color: white;
            padding: 14px 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            font-size: 14px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .lot-data-header i {
            font-size: 18px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
        }

        .lot-data-content {
            padding: 5px;
        }

        .lot-data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 10px;
        }

        .lot-data-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 10px;
            background: var(--sai-light-gray);
            border-radius: 8px;
            border-left: 3px solid var(--sai-orange);
            transition: all 0.2s ease;
        }

        .lot-data-item:hover {
            background: var(--sai-gray);
            transform: translateX(2px);
        }

        .lot-data-label {
            font-size: 10px;
            color: var(--sai-text-light);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .lot-data-value {
            font-size: 14px;
            color: var(--sai-text);
            font-weight: 700;
        }

        .lot-plan-container {
            position: relative;
            height: 250px;
            border: 2px solid var(--sai-border);
            border-radius: 12px;
            overflow: hidden;
            background: linear-gradient(135deg, #fafbfc 0%, #f5f7fa 100%);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.04);
            width: 100%;
        }

        #lot-plan-canvas {
            width: 100%;
            height: 100%;
        }

        .north-arrow {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 42px;
            height: 42px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
            color: var(--sai-text);
            background: white;
            border-radius: 10px;
            padding: 4px;
            box-shadow: var(--shadow-md);
            border: 2px solid var(--sai-border);
        }

        .north-arrow i {
            font-size: 20px;
            color: var(--sai-orange);
            margin-bottom: 2px;
        }

        .reservations-list {
            max-height: 300px;
            overflow-y: auto;
            border: 2px solid var(--sai-border);
            border-radius: 12px;
            padding: 12px;
            background: var(--sai-light-gray);
        }

        .reservation-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 4px solid var(--sai-purple);
            transition: all 0.3s ease;
        }

        .reservation-item:hover {
            transform: translateX(4px);
            box-shadow: var(--shadow-md);
        }

        .reservation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .reservation-lote {
            font-weight: 700;
            color: var(--sai-dark-blue);
        }

        .reservation-status {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .reservation-status.reserved {
            background: rgba(245, 158, 11, 0.1);
            color: var(--reserved-color);
        }

        .reservation-status.sold {
            background: rgba(239, 68, 68, 0.1);
            color: var(--sold-color);
        }

        .reservation-info {
            font-size: 12px;
            color: var(--sai-text-light);
        }

        .reservation-info span {
            display: block;
            margin-bottom: 2px;
        }

        .reservation-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .reservation-action {
            padding: 4px 8px;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reservation-action.confirm {
            background: var(--available-color);
            color: white;
        }

        .reservation-action.cancel {
            background: var(--sold-color);
            color: white;
        }

        .reservation-action:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }

        .dxf-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 43, 74, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .dxf-modal.hidden {
            display: none;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            width: 90%;
            max-width: 550px;
            max-height: 90vh;
            padding: 0;
            box-shadow: 0 20px 60px rgba(26, 43, 74, 0.3);
            overflow: hidden;
            animation: modalSlideIn 0.3s ease-out;
            display: flex;
            flex-direction: column;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            background: linear-gradient(135deg, var(--sai-dark-blue) 0%, var(--sai-blue) 100%);
            border-bottom: 3px solid var(--sai-orange);
            flex-shrink: 0;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 700;
            color: white;
            letter-spacing: 0.3px;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .modal-body {
            padding: 20px 25px;
            overflow-y: auto;
            flex: 1;
            max-height: calc(90vh - 140px);
        }

        .file-upload-area {
            border: 3px dashed var(--sai-purple);
            border-radius: 16px;
            padding: 40px 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
            background: linear-gradient(135deg, rgba(123, 104, 238, 0.05) 0%, rgba(157, 141, 247, 0.05) 100%);
        }

        .file-upload-area:hover {
            background: linear-gradient(135deg, rgba(123, 104, 238, 0.1) 0%, rgba(157, 141, 247, 0.1) 100%);
            border-color: var(--sai-light-purple);
            transform: translateY(-2px);
        }

        .upload-icon {
            font-size: 48px;
            background: linear-gradient(135deg, var(--sai-purple) 0%, var(--sai-light-purple) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 12px;
        }

        .upload-text {
            font-size: 16px;
            color: var(--sai-text);
            margin-bottom: 6px;
            font-weight: 600;
        }

        .upload-hint {
            font-size: 12px;
            color: var(--sai-text-light);
        }

        .coordinate-inputs {
            margin-top: 20px;
        }

        .input-group {
            margin-bottom: 14px;
        }

        .input-label {
            display: block;
            font-size: 12px;
            color: var(--sai-text);
            margin-bottom: 6px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .coordinate-input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid var(--sai-border);
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .coordinate-input:focus {
            outline: none;
            border-color: var(--sai-purple);
            box-shadow: 0 0 0 3px rgba(123, 104, 238, 0.1);
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
            padding: 0 25px 20px;
            flex-shrink: 0;
        }

        .modal-button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.3px;
        }

        .modal-button.primary {
            background: linear-gradient(135deg, var(--sai-orange) 0%, var(--sai-light-orange) 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(255, 140, 66, 0.3);
        }

        .modal-button.primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 140, 66, 0.4);
        }

        .modal-button.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .modal-button.secondary {
            background: var(--sai-light-gray);
            color: var(--sai-text);
            border: 2px solid var(--sai-border);
        }

        .modal-button.secondary:hover {
            background: var(--sai-gray);
            border-color: var(--sai-purple);
            transform: translateY(-2px);
        }

        #file-input {
            display: none;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(26, 43, 74, 0.85) 0%, rgba(44, 62, 95, 0.85) 100%);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(255, 255, 255, 0.2);
            border-top: 6px solid var(--sai-orange);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-text {
            margin-top: 20px;
            font-size: 16px;
            color: white;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .notification {
            position: fixed;
            top: 90px;
            right: 25px;
            background: white;
            padding: 18px 24px;
            border-radius: 14px;
            box-shadow: var(--shadow-lg);
            z-index: 1500;
            display: flex;
            align-items: center;
            gap: 15px;
            transform: translateX(120%);
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border: 2px solid var(--sai-border);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            border-left: 5px solid #10b981;
        }

        .notification.error {
            border-left: 5px solid #ef4444;
        }

        .notification.info {
            border-left: 5px solid var(--sai-purple);
        }

        .notification-icon {
            font-size: 22px;
        }

        .notification.success .notification-icon {
            color: #10b981;
        }

        .notification.error .notification-icon {
            color: #ef4444;
        }

        .notification.info .notification-icon {
            color: var(--sai-purple);
        }

        .notification-message {
            flex-grow: 1;
            color: var(--sai-text);
            font-weight: 500;
            font-size: 14px;
        }

        .notification-close {
            background: none;
            border: none;
            color: var(--sai-text-light);
            cursor: pointer;
            font-size: 18px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .notification-close:hover {
            background: var(--sai-light-gray);
            color: var(--sai-text);
        }

        .dimension-label {
            background: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
            color: var(--sai-text);
            box-shadow: var(--shadow-md);
            border: 2px solid var(--sai-purple);
        }

        .vertex-marker {
            background: linear-gradient(135deg, var(--sai-orange) 0%, var(--sai-light-orange) 100%);
            border: 3px solid white;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            box-shadow: var(--shadow-md);
        }

        .no-data-message {
            text-align: center;
            color: var(--sai-text-light);
            font-style: italic;
            padding: 30px 20px;
            font-size: 14px;
        }

        .scroll-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, rgba(123, 104, 238, 0.1) 0%, rgba(157, 141, 247, 0.1) 100%);
            color: var(--sai-purple);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 11px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            border: 1px solid var(--sai-purple);
        }

        .scroll-indicator.visible {
            opacity: 1;
        }

        .sidebar-shadow {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(to bottom, rgba(26, 43, 74, 0.08), transparent);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 5;
        }

        .sidebar-shadow.visible {
            opacity: 1;
        }

        .empty-lote-data {
            text-align: center;
            color: var(--sai-text-light);
            font-style: italic;
            padding: 50px 20px;
            font-size: 14px;
        }

        .empty-lote-data i {
            font-size: 56px;
            background: linear-gradient(135deg, var(--sai-purple) 0%, var(--sai-light-purple) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            display: block;
        }

        .data-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--sai-gray);
        }

        .data-item:last-child {
            border-bottom: none;
        }

        .data-label {
            font-size: 13px;
            color: var(--sai-text-light);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .data-value {
            font-size: 15px;
            color: var(--sai-text);
            font-weight: 700;
        }

        .price-tag {
            background: linear-gradient(135deg, var(--sai-orange) 0%, var(--sai-light-orange) 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 700;
            display: inline-block;
            margin-top: 8px;
            box-shadow: var(--shadow-sm);
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr 320px;
            }
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: 60px 1fr;
            }

            aside {
                display: none;
            }

            .logo-sub {
                display: none;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <div class="logo">
                <img src="img/LOGO2.png" alt="Logo de la empresa">
                <div class="logo-text">
                    <span class="logo-main">Gestor de Lotes</span>
                    <span class="logo-sub">SAI SOLUCIONES A LA INGENIERÍA</span>
                </div>
            </div>
            <div class="header-controls">
                <div class="view-toggle">
                    <button class="view-button active" data-view="map">Mapa</button>
                    <button class="view-button" data-view="satellite">Satélite</button>
                    <button class="view-button" data-view="terrain">Relieve</button>
                </div>
                <div class="map-tools">
                    <button class="tool-button" id="import-dxf-tool" title="Importar DXF">
                        <i class="fas fa-file-import"></i>
                    </button>
                    <button class="tool-button" id="zoom-in-tool" title="Acercar">
                        <i class="fas fa-search-plus"></i>
                    </button>
                    <button class="tool-button" id="zoom-out-tool" title="Alejar">
                        <i class="fas fa-search-minus"></i>
                    </button>
                    <button class="tool-button" id="fullscreen-tool" title="Pantalla completa">
                        <i class="fas fa-expand"></i>
                    </button>
                </div>
            </div>
        </header>

        <main>
            <div id="map-viewer"></div>
            <div class="coordinates">Lat: 0.0000, Lng: 0.0000</div>

            <!-- Leyenda de estados -->
            <div class="legend">
                <div class="legend-title">ESTADO DE LOTES</div>
                <div class="legend-item">
                    <div class="legend-color available"></div>
                    <span>Disponible</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color reserved"></div>
                    <span>Reservado</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color sold"></div>
                    <span>Vendido</span>
                </div>
            </div>
        </main>

        <aside>
            <div class="sidebar-shadow" id="sidebar-shadow"></div>

            <div class="sidebar-content" id="sidebar-content">
                <!-- Panel de Datos de Lote -->
                <div class="panel">
                    <div class="lot-data-panel" id="lot-data-panel">
                        <div class="lot-data-header">
                            <i class="fas fa-chart-area"></i> DATOS DE LOTE
                        </div>
                        <div class="lot-data-content">
                            <div id="lot-data-content">
                                <div class="empty-lote-data">
                                    <i class="fas fa-mouse-pointer"></i>
                                    Selecciona un lote para ver sus datos
                                </div>
                            </div>
                            <div class="lot-plan-container">
                                <canvas id="lot-plan-canvas"></canvas>
                                <div class="north-arrow">
                                    <i class="fas fa-location-arrow"></i>
                                    <span>N</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">
                        <i class="fas fa-sliders-h"></i> Controles
                    </div>
                    <button class="control-button primary" id="import-dxf-button">
                        <i class="fas fa-file-import"></i>
                        <span>Importar DXF</span>
                    </button>
                    <button class="control-button secondary" id="clear-button">
                        <i class="fas fa-eraser"></i>
                        <span>Limpiar Vista</span>
                    </button>
                </div>

                <div class="panel">
                    <div class="panel-title">
                        <i class="fas fa-handshake"></i> Reservas Activas
                    </div>
                    <div class="reservations-list" id="reservations-list">
                        <div class="no-data-message">No hay reservas activas</div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">
                        <i class="fas fa-chart-pie"></i> Información Adicional
                    </div>
                    <div class="data-item">
                        <span class="data-label">Total Manzanos:</span>
                        <span class="data-value" id="total-manzanos">0</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Total Lotes:</span>
                        <span class="data-value" id="total-lotes">0</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Disponibles:</span>
                        <span class="data-value" id="available-lotes" style="color: var(--available-color);">0</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Reservados:</span>
                        <span class="data-value" id="reserved-lotes" style="color: var(--reserved-color);">0</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Vendidos:</span>
                        <span class="data-value" id="sold-lotes" style="color: var(--sold-color);">0</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Área Total:</span>
                        <span class="data-value" id="total-area">0.00 ha</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Estado:</span>
                        <span class="data-value" style="color: #10b981;">● Activo</span>
                    </div>
                </div>
            </div>
        </aside>
    </div>

    <!-- Modal de Reserva -->
    <div class="dxf-modal hidden" id="reservation-modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Reservar Lote</span>
                <button class="modal-close" id="reservation-modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="input-group">
                    <label class="input-label">Lote a Reservar</label>
                    <input type="text" class="coordinate-input" id="reservation-lote" readonly>
                </div>
                <div class="input-group">
                    <label class="input-label">Nombre del Cliente *</label>
                    <input type="text" class="coordinate-input" id="reservation-name"
                        placeholder="Ingrese nombre completo">
                </div>
                <div class="input-group">
                    <label class="input-label">Teléfono *</label>
                    <input type="tel" class="coordinate-input" id="reservation-phone" placeholder="Ingrese teléfono">
                </div>
                <div class="input-group">
                    <label class="input-label">Email</label>
                    <input type="email" class="coordinate-input" id="reservation-email" placeholder="Ingrese email">
                </div>
                <div class="input-group">
                    <label class="input-label">Precio de Venta (USD)</label>
                    <input type="number" class="coordinate-input" id="reservation-price" placeholder="0.00" step="0.01">
                </div>
                <div class="input-group">
                    <label class="input-label">Monto Reserva (USD)</label>
                    <input type="number" class="coordinate-input" id="reservation-amount" placeholder="0.00"
                        step="0.01">
                </div>
                <div class="input-group">
                    <label class="input-label">Notas Adicionales</label>
                    <textarea class="coordinate-input" id="reservation-notes" rows="2"
                        placeholder="Ingrese notas adicionales"></textarea>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-button secondary" id="reservation-cancel">Cancelar</button>
                <button class="modal-button primary" id="reservation-confirm">Confirmar Reserva</button>
            </div>
        </div>
    </div>

    <!-- Modal DXF -->
    <div class="dxf-modal hidden" id="dxf-modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Importar archivo DXF</span>
                <button class="modal-close" id="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="file-upload-area" id="file-upload-area">
                    <div class="upload-icon"><i class="fas fa-cloud-upload-alt"></i></div>
                    <div class="upload-text">Arrastra tu archivo DXF aquí</div>
                    <div class="upload-hint">o haz clic para seleccionar</div>
                </div>
                <input type="file" id="file-input" accept=".dxf" />
                <div class="coordinate-inputs">
                    <div class="input-group">
                        <label class="input-label">Sistema de coordenadas</label>
                        <select class="coordinate-input" id="coord-system">
                            <option value="utm">UTM (Universal Transverse Mercator)</option>
                            <option value="latlong">Lat/Lng (Geográficas)</option>
                        </select>
                    </div>
                    <div class="input-group" id="utm-zone-group">
                        <label class="input-label">Zona UTM</label>
                        <input type="text" class="coordinate-input" id="utm-zone"
                            placeholder="Ej: 20 (para Bolivia: 19, 20 o 21)">
                    </div>
                    <div class="input-group" id="utm-hemisphere-group">
                        <label class="input-label">Hemisferio</label>
                        <select class="coordinate-input" id="utm-hemisphere">
                            <option value="south">Sur</option>
                            <option value="north">Norte</option>
                        </select>
                    </div>
                    <div class="input-group" id="ref-lat-group" style="display:none;">
                        <label class="input-label">Punto de referencia</label>
                        <input type="text" class="coordinate-input" id="ref-lat" placeholder="Latitud (ej: -21.5355)">
                    </div>
                    <div class="input-group" id="ref-lng-group" style="display:none;">
                        <input type="text" class="coordinate-input" id="ref-lng" placeholder="Longitud (ej: -63.6714)">
                    </div>
                    <div class="input-group" id="scale-group" style="display:none;">
                        <label class="input-label">Escala</label>
                        <input type="number" class="coordinate-input" id="scale-input" placeholder="1.0" value="1.0"
                            step="0.0001">
                    </div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-button secondary" id="cancel-button">Cancelar</button>
                <button class="modal-button primary" id="process-button" disabled>Procesar DXF</button>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loading">
        <div class="spinner"></div>
        <div class="loading-text">Procesando archivo...</div>
    </div>

    <div class="notification" id="notification">
        <div class="notification-icon">
            <i class="fas fa-info-circle"></i>
        </div>
        <div class="notification-message"></div>
        <button class="notification-close" id="notification-close">
            <i class="fas fa-times"></i>
        </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>

    <script>
        // Parser DXF
        if (typeof DxfParser === 'undefined') {
            window.DxfParser = function () {
                this.parseSync = function (dxfString) {
                    const lines = dxfString.split('\n').map(line => line.trim());
                    const entities = [];
                    let i = 0;
                    while (i < lines.length) {
                        if (lines[i] === '0' && lines[i + 1] === 'SECTION') {
                            i = this.parseSection(lines, i, entities);
                        } else { i++; }
                    }
                    console.log('Entidades encontradas:', entities.length);
                    return { entities: entities };
                };

                this.parseSection = function (lines, startIndex, entities) {
                    let i = startIndex + 2;
                    while (i < lines.length) {
                        if (lines[i] === '0') {
                            if (lines[i + 1] === 'ENDSEC') return i + 2;
                            const entityType = lines[i + 1];
                            if (entityType === 'LINE') i = this.parseLine(lines, i + 2, entities);
                            else if (entityType === 'LWPOLYLINE') i = this.parseLWPolyline(lines, i + 2, entities);
                            else if (entityType === 'POLYLINE') i = this.parsePolyline(lines, i + 2, entities);
                            else if (entityType === 'CIRCLE') i = this.parseCircle(lines, i + 2, entities);
                            else if (entityType === 'ARC') i = this.parseArc(lines, i + 2, entities);
                            else if (entityType === 'TEXT' || entityType === 'MTEXT') i = this.parseText(lines, i + 2, entities, entityType);
                            else if (entityType === 'DIMENSION') i = this.skipDimension(lines, i + 2);
                            else i += 2;
                        } else { i++; }
                    }
                    return i;
                };

                this.skipDimension = function (lines, startIndex) {
                    let i = startIndex;
                    while (i < lines.length && lines[i] !== '0') {
                        i += 2;
                    }
                    return i;
                };

                this.parseLine = function (lines, startIndex, entities) {
                    const entity = { type: 'LINE', vertices: [{}, {}] };
                    let i = startIndex;
                    while (i < lines.length && lines[i] !== '0') {
                        const code = lines[i], value = lines[i + 1];
                        if (code === '8') entity.layer = value;
                        else if (code === '62') entity.color = parseInt(value);
                        else if (code === '10') entity.vertices[0].x = parseFloat(value);
                        else if (code === '20') entity.vertices[0].y = parseFloat(value);
                        else if (code === '11') entity.vertices[1].x = parseFloat(value);
                        else if (code === '21') entity.vertices[1].y = parseFloat(value);
                        else if (code === '370') entity.lineweight = parseInt(value);
                        i += 2;
                    }
                    if (entity.vertices[0].x !== undefined && entity.vertices[1].x !== undefined) {
                        entities.push(entity);
                    }
                    return i;
                };

                this.parseLWPolyline = function (lines, startIndex, entities) {
                    const entity = { type: 'LWPOLYLINE', vertices: [], bulges: [] };
                    let i = startIndex, currentVertex = null, currentBulge = 0, closed = false;
                    while (i < lines.length && lines[i] !== '0') {
                        const code = lines[i], value = lines[i + 1];
                        if (code === '8') entity.layer = value;
                        else if (code === '62') entity.color = parseInt(value);
                        else if (code === '370') entity.lineweight = parseInt(value);
                        else if (code === '70') closed = (parseInt(value) & 1) === 1;
                        else if (code === '10') {
                            if (currentVertex && currentVertex.x !== undefined && currentVertex.y !== undefined) {
                                entity.vertices.push(currentVertex);
                                entity.bulges.push(currentBulge);
                                currentBulge = 0;
                            }
                            currentVertex = { x: parseFloat(value) };
                        }
                        else if (code === '20') { if (currentVertex) currentVertex.y = parseFloat(value); }
                        else if (code === '42') { currentBulge = parseFloat(value); }
                        i += 2;
                    }
                    if (currentVertex && currentVertex.x !== undefined && currentVertex.y !== undefined) {
                        entity.vertices.push(currentVertex);
                        entity.bulges.push(currentBulge);
                    }
                    entity.closed = closed;
                    if (entity.vertices.length > 0) {
                        while (entity.bulges.length < entity.vertices.length) entity.bulges.push(0);
                        entities.push(entity);
                    }
                    return i;
                };

                this.parsePolyline = function (lines, startIndex, entities) {
                    const entity = { type: 'POLYLINE', vertices: [] };
                    let i = startIndex, closed = false;
                    while (i < lines.length && lines[i] !== '0') {
                        const code = lines[i], value = lines[i + 1];
                        if (code === '8') entity.layer = value;
                        else if (code === '62') entity.color = parseInt(value);
                        else if (code === '70') closed = (parseInt(value) & 1) === 1;
                        else if (code === '370') entity.lineweight = parseInt(value);
                        i += 2;
                    }
                    while (i < lines.length) {
                        if (lines[i] === '0' && lines[i + 1] === 'VERTEX') {
                            const vertex = {};
                            i += 2;
                            while (i < lines.length && lines[i] !== '0') {
                                const code = lines[i], value = lines[i + 1];
                                if (code === '10') vertex.x = parseFloat(value);
                                else if (code === '20') vertex.y = parseFloat(value);
                                i += 2;
                            }
                            if (vertex.x !== undefined) entity.vertices.push(vertex);
                        } else if (lines[i] === '0' && lines[i + 1] === 'SEQEND') {
                            i += 2; break;
                        } else { i++; }
                    }
                    entity.closed = closed;
                    if (entity.vertices.length > 0) entities.push(entity);
                    return i;
                };

                this.parseCircle = function (lines, startIndex, entities) {
                    const entity = { type: 'CIRCLE' };
                    let i = startIndex;
                    while (i < lines.length && lines[i] !== '0') {
                        const code = lines[i], value = lines[i + 1];
                        if (code === '8') entity.layer = value;
                        else if (code === '62') entity.color = parseInt(value);
                        else if (code === '10') entity.x = parseFloat(value);
                        else if (code === '20') entity.y = parseFloat(value);
                        else if (code === '40') entity.radius = parseFloat(value);
                        else if (code === '370') entity.lineweight = parseInt(value);
                        i += 2;
                    }
                    if (entity.x !== undefined && entity.radius !== undefined) entities.push(entity);
                    return i;
                };

                this.parseArc = function (lines, startIndex, entities) {
                    const entity = { type: 'ARC' };
                    let i = startIndex;
                    while (i < lines.length && lines[i] !== '0') {
                        const code = lines[i], value = lines[i + 1];
                        if (code === '8') entity.layer = value;
                        else if (code === '62') entity.color = parseInt(value);
                        else if (code === '10') entity.x = parseFloat(value);
                        else if (code === '20') entity.y = parseFloat(value);
                        else if (code === '40') entity.radius = parseFloat(value);
                        else if (code === '50') entity.startAngle = parseFloat(value) * Math.PI / 180;
                        else if (code === '51') entity.endAngle = parseFloat(value) * Math.PI / 180;
                        else if (code === '370') entity.lineweight = parseInt(value);
                        i += 2;
                    }
                    if (entity.x !== undefined && entity.radius !== undefined) entities.push(entity);
                    return i;
                };

                this.parseText = function (lines, startIndex, entities, type) {
                    const entity = { type: type };
                    let i = startIndex;
                    while (i < lines.length && lines[i] !== '0') {
                        const code = lines[i], value = lines[i + 1];
                        if (code === '8') entity.layer = value;
                        else if (code === '62') entity.color = parseInt(value);
                        else if (code === '10') entity.x = parseFloat(value);
                        else if (code === '20') entity.y = parseFloat(value);
                        else if (code === '11') entity.x2 = parseFloat(value);
                        else if (code === '21') entity.y2 = parseFloat(value);
                        else if (code === '1') entity.text = value;
                        else if (code === '40') entity.height = parseFloat(value);
                        else if (code === '50') entity.rotation = parseFloat(value);
                        else if (code === '41') entity.widthFactor = parseFloat(value);
                        else if (code === '7') entity.style = value;
                        else if (code === '72') entity.halign = parseInt(value);
                        else if (code === '73') entity.valign = parseInt(value);
                        i += 2;
                    }
                    if (entity.x !== undefined && entity.text) {
                        entity.position = { x: entity.x, y: entity.y };
                        if (entity.x2 !== undefined && entity.y2 !== undefined) {
                            entity.position2 = { x: entity.x2, y: entity.y2 };
                        }
                        entities.push(entity);
                    }
                    return i;
                };
            };
        }

        // Variables globales
        let map;
        let dxfLayer;
        let lotesLayer;
        let manzanosLayer;
        let selectedLote = null;
        let manzanosData = {};
        let lotesData = {};
        let dxfData = null;
        let allBounds = null;
        let reservations = [];

        // Inicialización
        document.addEventListener('DOMContentLoaded', function () {
            initMap();
            setupEventListeners();
            setupScrollBehavior();
            loadReservations();
            
            // Cargar automáticamente el archivo DXF al iniciar
            setTimeout(() => {
                loadDefaultDXF();
            }, 1000);
        });

        function loadDefaultDXF() {
            // Establecer valores predeterminados para zona 19 sur
            document.getElementById('coord-system').value = 'utm';
            document.getElementById('utm-zone').value = '19';
            document.getElementById('utm-hemisphere').value = 'south';
            
            // Mostrar los campos apropiados
            document.getElementById('utm-zone-group').style.display = 'block';
            document.getElementById('utm-hemisphere-group').style.display = 'block';
            document.getElementById('ref-lat-group').style.display = 'none';
            document.getElementById('ref-lng-group').style.display = 'none';
            document.getElementById('scale-group').style.display = 'none';
            
            // Cargar el archivo DXF
            fetch('PLANO DE URB PARA VISOR.dxf')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('No se pudo cargar el archivo DXF');
                    }
                    return response.text();
                })
                .then(dxfText => {
                    try {
                        if (typeof DxfParser === 'undefined') {
                            showNotification('La librería DXF Parser no está cargada. Por favor recarga la página.', 'error');
                            return;
                        }

                        const parser = new DxfParser();
                        dxfData = parser.parseSync(dxfText);
                        
                        // Procesar el archivo DXF automáticamente
                        document.getElementById('loading').classList.add('active');
                        
                        setTimeout(() => {
                            try {
                                processDXF(dxfData);
                                document.getElementById('loading').classList.remove('active');
                                showNotification('Archivo DXF cargado automáticamente', 'success');
                            } catch (error) {
                                console.error('Error procesando DXF:', error);
                                showNotification('Error al procesar el archivo DXF', 'error');
                                document.getElementById('loading').classList.remove('active');
                            }
                        }, 500);
                    } catch (err) {
                        console.error('Error completo:', err);
                        showNotification('Error al leer el archivo DXF: ' + err.message, 'error');
                    }
                })
                .catch(error => {
                    console.error('Error al cargar el archivo DXF:', error);
                    showNotification('No se pudo cargar el archivo DXF predeterminado', 'error');
                });
        }

        function initMap() {
            map = L.map('map-viewer', {
                center: [-21.5355, -63.6714],
                zoom: 13,
                zoomControl: false,
                maxZoom: 22,
                minZoom: 3
            });

            L.control.zoom({ position: 'topright' }).addTo(map);

            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap',
                maxZoom: 22,
                maxNativeZoom: 19
            });

            const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '© Esri',
                maxZoom: 22,
                maxNativeZoom: 19
            });

            const terrainLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenTopoMap',
                maxZoom: 17
            });

            osmLayer.addTo(map);
            let currentLayer = osmLayer;

            manzanosLayer = L.featureGroup().addTo(map);
            lotesLayer = L.featureGroup().addTo(map);
            dxfLayer = L.featureGroup().addTo(map);

            manzanosLayer.setZIndex(100);
            lotesLayer.setZIndex(200);
            dxfLayer.setZIndex(150);

            document.querySelectorAll('.view-button').forEach(button => {
                button.addEventListener('click', function () {
                    document.querySelectorAll('.view-button').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    const view = this.getAttribute('data-view');
                    if (map.hasLayer(currentLayer)) map.removeLayer(currentLayer);
                    if (view === 'map') currentLayer = osmLayer;
                    else if (view === 'satellite') currentLayer = satelliteLayer;
                    else if (view === 'terrain') currentLayer = terrainLayer;
                    map.addLayer(currentLayer);
                });
            });

            map.on('mousemove', function (e) {
                document.querySelector('.coordinates').textContent =
                    `Lat: ${e.latlng.lat.toFixed(4)}, Lng: ${e.latlng.lng.toFixed(4)}`;
            });
        }

        function setupEventListeners() {
            // Botones de importación DXF
            document.getElementById('import-dxf-tool').addEventListener('click', showDxfModal);
            document.getElementById('import-dxf-button').addEventListener('click', showDxfModal);

            // Modal DXF
            document.getElementById('modal-close').addEventListener('click', hideDxfModal);
            document.getElementById('cancel-button').addEventListener('click', hideDxfModal);

            // Modal de Reserva
            document.getElementById('reservation-modal-close').addEventListener('click', hideReservationModal);
            document.getElementById('reservation-cancel').addEventListener('click', hideReservationModal);
            document.getElementById('reservation-confirm').addEventListener('click', confirmReservation);

            // Control para cambiar entre UTM y Lat/Lng
            document.getElementById('coord-system').addEventListener('change', function () {
                const isUTM = this.value === 'utm';
                document.getElementById('utm-zone-group').style.display = isUTM ? 'block' : 'none';
                document.getElementById('utm-hemisphere-group').style.display = isUTM ? 'block' : 'none';
                document.getElementById('ref-lat-group').style.display = isUTM ? 'none' : 'block';
                document.getElementById('ref-lng-group').style.display = isUTM ? 'none' : 'block';
                document.getElementById('scale-group').style.display = isUTM ? 'none' : 'block';
            });

            // File upload
            const fileUploadArea = document.getElementById('file-upload-area');
            const fileInput = document.getElementById('file-input');

            fileUploadArea.addEventListener('click', () => fileInput.click());
            fileUploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                fileUploadArea.classList.add('dragover');
            });
            fileUploadArea.addEventListener('dragleave', () => fileUploadArea.classList.remove('dragover'));
            fileUploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                fileUploadArea.classList.remove('dragover');
                if (e.dataTransfer.files.length > 0) handleFileSelect(e.dataTransfer.files[0]);
            });
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) handleFileSelect(e.target.files[0]);
            });

            // Botón de procesar DXF
            document.getElementById('process-button').addEventListener('click', processDxfFile);

            // Botones de herramientas
            document.getElementById('zoom-in-tool').addEventListener('click', () => map.zoomIn());
            document.getElementById('zoom-out-tool').addEventListener('click', () => map.zoomOut());
            document.getElementById('reset-view-tool').addEventListener('click', () => {
                if (allBounds) {
                    map.fitBounds(allBounds, { padding: [50, 50] });
                }
            });

            document.getElementById('fullscreen-tool').addEventListener('click', function () {
                const elem = document.documentElement;
                if (!document.fullscreenElement) {
                    if (elem.requestFullscreen) elem.requestFullscreen();
                    this.innerHTML = '<i class="fas fa-compress"></i>';
                } else {
                    if (document.exitFullscreen) document.exitFullscreen();
                    this.innerHTML = '<i class="fas fa-expand"></i>';
                }
            });

            // Botón de limpiar vista
            document.getElementById('clear-button').addEventListener('click', clearView);

            // Notificación
            document.getElementById('notification-close').addEventListener('click', hideNotification);
        }

        function setupScrollBehavior() {
            const sidebarContent = document.getElementById('sidebar-content');
            const scrollIndicator = document.getElementById('scroll-indicator');
            const sidebarShadow = document.getElementById('sidebar-shadow');

            function checkScroll() {
                const hasScroll = sidebarContent.scrollHeight > sidebarContent.clientHeight;
                const isScrolled = sidebarContent.scrollTop > 10;

                if (hasScroll) {
                    scrollIndicator.classList.add('visible');
                    if (isScrolled) {
                        sidebarShadow.classList.add('visible');
                    } else {
                        sidebarShadow.classList.remove('visible');
                    }
                } else {
                    scrollIndicator.classList.remove('visible');
                    sidebarShadow.classList.remove('visible');
                }
            }

            sidebarContent.addEventListener('scroll', function () {
                checkScroll();
                clearTimeout(this.scrollTimeout);
                this.scrollTimeout = setTimeout(() => {
                    const maxScroll = this.scrollHeight - this.clientHeight;
                    if (this.scrollTop > maxScroll - 50) {
                        this.scrollTo({
                            top: maxScroll,
                            behavior: 'smooth'
                        });
                    }
                }, 150);
            });

            checkScroll();
            window.addEventListener('resize', checkScroll);

            let indicatorTimeout;
            sidebarContent.addEventListener('scroll', function () {
                clearTimeout(indicatorTimeout);
                indicatorTimeout = setTimeout(() => {
                    scrollIndicator.classList.remove('visible');
                }, 3000);
            });
        }

        function showDxfModal() {
            document.getElementById('dxf-modal').classList.remove('hidden');
        }

        function hideDxfModal() {
            document.getElementById('dxf-modal').classList.add('hidden');
        }

        function showReservationModal() {
            if (!selectedLote) return;

            document.getElementById('reservation-lote').value = selectedLote.name;
            document.getElementById('reservation-name').value = '';
            document.getElementById('reservation-phone').value = '';
            document.getElementById('reservation-email').value = '';
            document.getElementById('reservation-price').value = '';
            document.getElementById('reservation-amount').value = '';
            document.getElementById('reservation-notes').value = '';

            document.getElementById('reservation-modal').classList.remove('hidden');
        }

        function hideReservationModal() {
            document.getElementById('reservation-modal').classList.add('hidden');
        }

        function confirmReservation() {
            const name = document.getElementById('reservation-name').value.trim();
            const phone = document.getElementById('reservation-phone').value.trim();
            const email = document.getElementById('reservation-email').value.trim();
            const price = parseFloat(document.getElementById('reservation-price').value) || 0;
            const amount = parseFloat(document.getElementById('reservation-amount').value) || 0;
            const notes = document.getElementById('reservation-notes').value.trim();

            if (!name || !phone) {
                showNotification('Por favor complete los campos obligatorios', 'error');
                return;
            }

            const reservation = {
                id: Date.now(),
                lote: selectedLote.name,
                manzano: selectedLote.manzano,
                clientName: name,
                clientPhone: phone,
                clientEmail: email,
                price: price,
                reservationAmount: amount,
                notes: notes,
                status: 'reserved',
                date: new Date().toISOString()
            };

            reservations.push(reservation);
            saveReservations();

            // Actualizar estado del lote
            selectedLote.status = 'reserved';
            updateLoteStyle(selectedLote);

            updateReservationsList();
            updateStatistics();
            hideReservationModal();

            showNotification('Reserva realizada exitosamente', 'success');
        }

        function loadReservations() {
            const saved = localStorage.getItem('lotes_reservations');
            if (saved) {
                reservations = JSON.parse(saved);
                updateReservationsList();
                updateStatistics();
            }
        }

        function saveReservations() {
            localStorage.setItem('lotes_reservations', JSON.stringify(reservations));
        }

        function updateReservationsList() {
            const container = document.getElementById('reservations-list');
            const activeReservations = reservations.filter(r => r.status === 'reserved');

            if (activeReservations.length === 0) {
                container.innerHTML = '<div class="no-data-message">No hay reservas activas</div>';
                return;
            }

            container.innerHTML = '';
            activeReservations.forEach(reservation => {
                const item = document.createElement('div');
                item.className = 'reservation-item';
                item.innerHTML = `
                    <div class="reservation-header">
                        <span class="reservation-lote">${reservation.lote}</span>
                        <span class="reservation-status ${reservation.status}">${reservation.status === 'reserved' ? 'Reservado' : 'Vendido'}</span>
                    </div>
                    <div class="reservation-info">
                        <span><i class="fas fa-user"></i> ${reservation.clientName}</span>
                        <span><i class="fas fa-phone"></i> ${reservation.clientPhone}</span>
                        ${reservation.clientEmail ? `<span><i class="fas fa-envelope"></i> ${reservation.clientEmail}</span>` : ''}
                        ${reservation.price ? `<span><i class="fas fa-dollar-sign"></i> $${reservation.price.toFixed(2)}</span>` : ''}
                    </div>
                    <div class="reservation-actions">
                        <button class="reservation-action confirm" onclick="confirmSale(${reservation.id})">
                            <i class="fas fa-check"></i> Vender
                        </button>
                        <button class="reservation-action cancel" onclick="cancelReservation(${reservation.id})">
                            <i class="fas fa-times"></i> Cancelar
                        </button>
                    </div>
                `;
                container.appendChild(item);
            });
        }

        function confirmSale(reservationId) {
            const reservation = reservations.find(r => r.id === reservationId);
            if (reservation) {
                reservation.status = 'sold';
                const lote = lotesData[reservation.lote];
                if (lote) {
                    lote.status = 'sold';
                    updateLoteStyle(lote);
                }
                saveReservations();
                updateReservationsList();
                updateStatistics();
                showNotification('Venta confirmada exitosamente', 'success');
            }
        }

        function cancelReservation(reservationId) {
            const reservation = reservations.find(r => r.id === reservationId);
            if (reservation) {
                reservation.status = 'cancelled';
                const lote = lotesData[reservation.lote];
                if (lote) {
                    lote.status = 'available';
                    updateLoteStyle(lote);
                }
                saveReservations();
                updateReservationsList();
                updateStatistics();
                showNotification('Reserva cancelada', 'info');
            }
        }

        function updateLoteStyle(lote) {
            if (!lote || !lote.polygon) return;

            let color = '#8B4513';
            let fillOpacity = 0.3;

            switch (lote.status) {
                case 'available':
                    color = '#10b981';
                    fillOpacity = 0.3;
                    break;
                case 'reserved':
                    color = '#f59e0b';
                    fillOpacity = 0.5;
                    break;
                case 'sold':
                    color = '#ef4444';
                    fillOpacity = 0.5;
                    break;
            }

            lote.polygon.setStyle({
                color: color,
                fillOpacity: fillOpacity,
                weight: 2
            });
        }

        function handleFileSelect(file) {
            if (!file.name.toLowerCase().endsWith('.dxf')) {
                showNotification('Por favor selecciona un archivo DXF', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    if (typeof DxfParser === 'undefined') {
                        showNotification('La librería DXF Parser no está cargada. Por favor recarga la página.', 'error');
                        return;
                    }

                    const parser = new DxfParser();
                    dxfData = parser.parseSync(e.target.result);

                    document.querySelector('.upload-text').textContent = file.name;
                    document.querySelector('.upload-hint').textContent = 'Archivo cargado exitosamente';
                    document.getElementById('process-button').disabled = false;

                } catch (err) {
                    console.error('Error completo:', err);
                    showNotification('Error al leer el archivo DXF: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        function processDxfFile() {
            if (!dxfData) return;

            document.getElementById('loading').classList.add('active');
            document.getElementById('dxf-modal').classList.add('hidden');

            setTimeout(() => {
                try {
                    processDXF(dxfData);
                    document.getElementById('loading').classList.remove('active');
                    showNotification('Archivo DXF procesado correctamente', 'success');
                } catch (error) {
                    console.error('Error procesando DXF:', error);
                    showNotification('Error al procesar el archivo DXF', 'error');
                    document.getElementById('loading').classList.remove('active');
                }
            }, 500);
        }

        function createTextOverlay(textEntity, coordSystem, utmZone, hemisphere, refLat, refLng, scale) {
            if (!textEntity.text || !textEntity.position) {
                return null;
            }

            const text = textEntity.text.replace(/\\P/g, '\n').replace(/%%[d,u]/g, '');

            let geometricCenterDxf;
            const halign = textEntity.halign || 0;
            const valign = textEntity.valign || 0;

            if (halign === 1 && (valign === 2 || valign === 1)) {
                geometricCenterDxf = { x: textEntity.position.x, y: textEntity.position.y };
            }
            else if (textEntity.position2) {
                geometricCenterDxf = {
                    x: (textEntity.position.x + textEntity.position2.x) / 2,
                    y: (textEntity.position.y + textEntity.position2.y) / 2
                };
            }
            else {
                console.warn('Texto sin punto de alineación, usando punto de inserción como centro:', textEntity.text);
                geometricCenterDxf = { x: textEntity.position.x, y: textEntity.position.y };
            }

            const position = convertDXFToLatLng(geometricCenterDxf, coordSystem, utmZone, hemisphere, refLat, refLng, scale);

            const canvasFontSize = 64;
            const color = getColorFromDXF(textEntity.color);
            const dxfTextHeight = textEntity.height || 2.0;
            const dxfUnitsToMeters = 1.5;
            const realWorldHeight = dxfTextHeight * dxfUnitsToMeters;
            const rotationInRadians = -(textEntity.rotation || 0) * Math.PI / 180;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.font = `bold ${canvasFontSize}px Arial`;
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';

            const lines = text.split('\n');
            let maxWidth = 0;
            lines.forEach(line => {
                const metrics = tempCtx.measureText(line);
                maxWidth = Math.max(maxWidth, metrics.width);
            });
            const lineHeight = canvasFontSize * 1.2;
            const textHeight = lines.length * lineHeight;

            const realWorldWidth = (maxWidth / textHeight) * realWorldHeight;
            const halfWidth = realWorldWidth / 2;
            const halfHeight = realWorldHeight / 2;

            const localCorners = [
                { x: -halfWidth, y: -halfHeight },
                { x: halfWidth, y: -halfHeight },
                { x: halfWidth, y: halfHeight },
                { x: -halfWidth, y: halfHeight }
            ];

            const cos = Math.cos(rotationInRadians);
            const sin = Math.sin(rotationInRadians);
            const rotatedLocalCorners = localCorners.map(corner => ({
                x: corner.x * cos - corner.y * sin,
                y: corner.x * sin + corner.y * cos
            }));

            const metersPerDegreeLat = 111320;
            const metersPerDegreeLng = metersPerDegreeLat * Math.cos(position[0] * Math.PI / 180);

            const geoCorners = rotatedLocalCorners.map(corner => {
                const latOffset = corner.y / metersPerDegreeLat;
                const lngOffset = corner.x / metersPerDegreeLng;
                return [position[0] + latOffset, position[1] + lngOffset];
            });

            const bounds = L.latLngBounds(geoCorners);

            const unrotatedWidth = maxWidth;
            const unrotatedHeight = textHeight;
            const cornersForCanvas = [
                { x: -unrotatedWidth / 2, y: -unrotatedHeight / 2 },
                { x: unrotatedWidth / 2, y: -unrotatedHeight / 2 },
                { x: unrotatedWidth / 2, y: unrotatedHeight / 2 },
                { x: -unrotatedWidth / 2, y: unrotatedHeight / 2 }
            ];

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            cornersForCanvas.forEach(corner => {
                const rotatedX = corner.x * cos - corner.y * sin;
                const rotatedY = corner.x * sin + corner.y * cos;
                minX = Math.min(minX, rotatedX);
                minY = Math.min(minY, rotatedY);
                maxX = Math.max(maxX, rotatedX);
                maxY = Math.max(maxY, rotatedY);
            });

            const finalCanvasWidth = Math.ceil(maxX - minX);
            const finalCanvasHeight = Math.ceil(maxY - minY);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = finalCanvasWidth;
            canvas.height = finalCanvasHeight;

            ctx.font = `bold ${canvasFontSize}px Arial`;
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.save();
            ctx.translate(finalCanvasWidth / 2, finalCanvasHeight / 2);
            ctx.rotate(rotationInRadians);

            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 4;
            ctx.lineWidth = 5;
            ctx.strokeStyle = 'white';
            ctx.strokeText(text, 0, 0);
            ctx.fillText(text, 0, 0);
            ctx.restore();

            const imageUrl = canvas.toDataURL('image/png');

            return L.imageOverlay(imageUrl, bounds, {
                interactive: false,
                zIndex: 250
            });
        }

        function processDXF(dxf) {
            dxfLayer.clearLayers();
            lotesLayer.clearLayers();
            manzanosLayer.clearLayers();

            manzanosData = {};
            lotesData = {};
            allBounds = null;

            const coordSystem = document.getElementById('coord-system').value;
            const utmZone = document.getElementById('utm-zone').value || '20';
            const hemisphere = document.getElementById('utm-hemisphere').value;
            let refLat = 0, refLng = 0, scale = 0.00001;

            if (coordSystem === 'utm') {
                if (!utmZone || isNaN(utmZone)) {
                    showNotification('Por favor ingresa una zona UTM válida', 'error');
                    return;
                }
            } else {
                refLat = parseFloat(document.getElementById('ref-lat').value) || 0;
                refLng = parseFloat(document.getElementById('ref-lng').value) || 0;
                scale = parseFloat(document.getElementById('scale-input').value) || 0.00001;
            }

            let bounds = null;
            if (!dxf.entities) return;

            dxf.entities.forEach(entity => {
                try {
                    if (entity.type === 'LWPOLYLINE' || entity.type === 'POLYLINE') {
                        if (entity.vertices.length === 0) return;

                        let points = [];
                        const numSegments = entity.closed ? entity.vertices.length : entity.vertices.length - 1;

                        for (let i = 0; i < numSegments; i++) {
                            const v1 = entity.vertices[i];
                            const v2 = entity.vertices[(i + 1) % entity.vertices.length];
                            const bulge = (entity.bulges && entity.bulges[i]) ? entity.bulges[i] : 0;

                            if (i === 0) points.push(convertDXFToLatLng(v1, coordSystem, utmZone, hemisphere, refLat, refLng, scale));

                            if (Math.abs(bulge) > 0.0001) {
                                const arcPoints = createBulgeArc(v1, v2, bulge, coordSystem, utmZone, hemisphere, refLat, refLng, scale, 96);
                                points = points.concat(arcPoints);
                            }

                            points.push(convertDXFToLatLng(v2, coordSystem, utmZone, hemisphere, refLat, refLng, scale));
                        }

                        if (points.length < 2) return;

                        const color = getColorFromDXF(entity.color);
                        const lineWeight = getLineWeightInPixels(entity.lineweight);

                        const layerName = (entity.layer || '').toUpperCase();
                        const isManzano = layerName.startsWith('MZ.') || layerName.startsWith('MZNO') || layerName.includes('MANZANO');
                        const isLote = layerName.startsWith('LOTE ');

                        if (isManzano || isLote) {
                            const polygon = L.polygon(points, {
                                color: isManzano ? '#4285F4' : '#8B4513',
                                weight: lineWeight,
                                fillOpacity: isManzano ? 0 : 0.3,
                                smoothFactor: 0
                            });

                            let name = '';
                            if (isManzano) {
                                name = layerName.replace('MZ.', '').replace('MZNO', '').replace('MANZANO', '').trim();

                                if (!manzanosData[name]) {
                                    const expandedVerticesManzano = createExpandedVertices(entity.vertices, entity.bulges || []);

                                    manzanosData[name] = {
                                        name: name,
                                        polygon: polygon,
                                        lotes: [],
                                        area: calculateAreaDXF(expandedVerticesManzano, [])
                                    };
                                }

                                polygon.addTo(manzanosLayer);
                                polygon.options.interactive = false;
                                polygon.on('click', () => selectManzano(name));
                            } else if (isLote) {
                                const loteParts = layerName.replace('LOTE ', '').split(' ');
                                const manzanoLetra = loteParts[0];
                                const loteNumero = loteParts[1];

                                name = layerName;

                                const expandedVertices = createExpandedVertices(entity.vertices, entity.bulges || []);
                                const area = calculateAreaDXF(expandedVertices, []);

                                const existingReservation = reservations.find(r => r.lote === name);
                                let status = 'available';
                                if (existingReservation) {
                                    status = existingReservation.status;
                                }

                                lotesData[name] = {
                                    name: name,
                                    polygon: polygon,
                                    area: area,
                                    vertices: entity.vertices,
                                    expandedVertices: expandedVertices,
                                    layer: entity.layer,
                                    manzano: manzanoLetra,
                                    loteNumero: loteNumero,
                                    points: points,
                                    bulges: entity.bulges || [],
                                    status: status,
                                    price: 0
                                };

                                updateLoteStyle(lotesData[name]);

                                polygon.addTo(lotesLayer);
                                polygon.options.loteName = name;
                                polygon.bringToFront();
                                polygon.on('click', () => selectLote(name));
                            }
                        } else {
                            const polyline = L.polyline(points, {
                                color: color,
                                weight: lineWeight,
                                opacity: 0.8
                            });

                            polyline.addTo(dxfLayer);
                        }

                        points.forEach(point => {
                            if (!bounds) bounds = L.latLngBounds([point]);
                            else bounds.extend(point);
                        });
                    } else if (entity.type === 'LINE') {
                        if (!entity.vertices || entity.vertices.length < 2) return;

                        const p1 = convertDXFToLatLng(entity.vertices[0], coordSystem, utmZone, hemisphere, refLat, refLng, scale);
                        const p2 = convertDXFToLatLng(entity.vertices[1], coordSystem, utmZone, hemisphere, refLat, refLng, scale);

                        const color = getColorFromDXF(entity.color);
                        const lineWeight = getLineWeightInPixels(entity.lineweight);

                        const line = L.polyline([p1, p2], {
                            color: color,
                            weight: lineWeight,
                            opacity: 0.8
                        });

                        line.addTo(dxfLayer);

                        [p1, p2].forEach(point => {
                            if (!bounds) bounds = L.latLngBounds([point]);
                            else bounds.extend(point);
                        });
                    } else if (entity.type === 'TEXT' || entity.type === 'MTEXT') {
                        if (!entity.position) return;

                        const text = entity.text || '';
                        if (text.includes('\\A') || /^\d+:\d+\.\d+m$/.test(text.trim())) {
                            return;
                        }

                        const textOverlay = createTextOverlay(entity, coordSystem, utmZone, hemisphere, refLat, refLng, scale);

                        if (textOverlay) {
                            textOverlay.addTo(dxfLayer);

                            const overlayBounds = textOverlay.getBounds();
                            if (!bounds) bounds = overlayBounds;
                            else bounds.extend(overlayBounds);
                        }
                    } else if (entity.type === 'CIRCLE') {
                        if (entity.x === undefined || entity.y === undefined || entity.radius === undefined) return;

                        const center = convertDXFToLatLng({ x: entity.x, y: entity.y }, coordSystem, utmZone, hemisphere, refLat, refLng, scale);
                        const radiusInMeters = entity.radius * scale * 111000;

                        const color = getColorFromDXF(entity.color);
                        const lineWeight = getLineWeightInPixels(entity.lineweight);

                        const circle = L.circle(center, {
                            radius: radiusInMeters,
                            color: color,
                            weight: lineWeight,
                            fillOpacity: 0.1
                        });

                        circle.addTo(dxfLayer);

                        if (!bounds) bounds = L.latLngBounds([center]);
                        else bounds.extend(center);
                    } else if (entity.type === 'ARC') {
                        if (entity.x === undefined || entity.y === undefined || entity.radius === undefined) return;

                        const center = convertDXFToLatLng({ x: entity.x, y: entity.y }, coordSystem, utmZone, hemisphere, refLat, refLng, scale);
                        const radiusInMeters = entity.radius * scale * 111000;

                        const color = getColorFromDXF(entity.color);
                        const lineWeight = getLineWeightInPixels(entity.lineweight);

                        const startAngle = entity.startAngle || 0;
                        const endAngle = entity.endAngle || Math.PI;
                        const points = [];

                        for (let angle = startAngle; angle <= endAngle; angle += Math.PI / 36) {
                            const x = entity.x + entity.radius * Math.cos(angle);
                            const y = entity.y + entity.radius * Math.sin(angle);
                            points.push(convertDXFToLatLng({ x, y }, coordSystem, utmZone, hemisphere, refLat, refLng, scale));
                        }

                        const arc = L.polyline(points, {
                            color: color,
                            weight: lineWeight,
                            fillOpacity: 0
                        });

                        arc.addTo(dxfLayer);

                        points.forEach(point => {
                            if (!bounds) bounds = L.latLngBounds([point]);
                            else bounds.extend(point);
                        });
                    }
                } catch (err) {
                    console.warn('Error procesando entidad:', err);
                }
            });

            assignLotesToManzanos();
            updateStatistics();

            allBounds = bounds;

            if (bounds && Object.keys(manzanosData).length > 0) {
                map.fitBounds(bounds, { padding: [50, 50] });
            } else {
                showNotification('No se encontraron manzanos o lotes válidos en el DXF', 'error');
            }

            setTimeout(() => {
                const sidebarContent = document.getElementById('sidebar-content');
                const scrollIndicator = document.getElementById('scroll-indicator');
                if (sidebarContent.scrollHeight > sidebarContent.clientHeight) {
                    scrollIndicator.classList.add('visible');
                }
            }, 100);
        }

        function assignLotesToManzanos() {
            Object.keys(lotesData).forEach(loteName => {
                const lote = lotesData[loteName];
                const manzanoLetra = lote.manzano;

                if (manzanosData[manzanoLetra]) {
                    manzanosData[manzanoLetra].lotes.push(loteName);
                } else {
                    console.warn(`No se encontró el manzano "${manzanoLetra}" para el lote "${loteName}"`);
                }
            });
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].lat, yi = polygon[i].lng;
                const xj = polygon[j].lat, yj = polygon[j].lng;

                const intersect = ((yi > point.lng) != (yj > point.lng))
                    && (point.lat < (xj - xi) * (point.lng - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function updateManzanosList() {
            // Ya no necesitamos actualizar la lista de manzanos
        }

        function updateLotesList() {
            // Ya no necesitamos actualizar la lista de lotes
        }

        function updateStatistics() {
            document.getElementById('total-manzanos').textContent = Object.keys(manzanosData).length;
            document.getElementById('total-lotes').textContent = Object.keys(lotesData).length;

            let availableCount = 0;
            let reservedCount = 0;
            let soldCount = 0;
            let totalArea = 0;

            Object.values(lotesData).forEach(lote => {
                totalArea += lote.area;
                switch (lote.status) {
                    case 'available':
                        availableCount++;
                        break;
                    case 'reserved':
                        reservedCount++;
                        break;
                    case 'sold':
                        soldCount++;
                        break;
                }
            });

            document.getElementById('available-lotes').textContent = availableCount;
            document.getElementById('reserved-lotes').textContent = reservedCount;
            document.getElementById('sold-lotes').textContent = soldCount;
            document.getElementById('total-area').textContent = `${totalArea.toFixed(2)} m²`;
        }

        function filterLotesByManzano(manzanoName) {
            // Ya no necesitamos filtrar lotes por manzano
        }

        function selectManzano(manzanoName) {
            const manzano = manzanosData[manzanoName];
            if (!manzano) return;

            manzanosLayer.eachLayer(layer => {
                layer.setStyle({ fillOpacity: 0 });
            });

            manzano.polygon.setStyle({ fillOpacity: 0.1 });

            lotesLayer.bringToFront();

            map.fitBounds(manzano.polygon.getBounds(), { padding: [50, 50] });

            showNotification(`Manzano seleccionado: ${manzanoName}`, 'info');
        }

        function selectLote(loteName) {
            const lote = lotesData[loteName];
            if (!lote) return;

            lotesLayer.eachLayer(layer => {
                layer.setStyle({ fillOpacity: 0.3, weight: 2 });
            });

            lote.polygon.setStyle({ fillOpacity: 0.5, weight: 3 });

            lote.polygon.bringToFront();
            lotesLayer.bringToFront();

            map.fitBounds(lote.polygon.getBounds(), { padding: [50, 50] });

            selectedLote = lote;

            showLoteDetails(lote);
        }

        function showLoteDetails(lote) {
            const lotDataContent = document.getElementById('lot-data-content');
            const perimeter = calculatePerimeter(lote.polygon.getLatLngs()[0]);

            let statusText = 'Disponible';
            let statusColor = 'var(--available-color)';
            let actionButton = '';

            switch (lote.status) {
                case 'reserved':
                    statusText = 'Reservado';
                    statusColor = 'var(--reserved-color)';
                    break;
                case 'sold':
                    statusText = 'Vendido';
                    statusColor = 'var(--sold-color)';
                    break;
                default:
                    actionButton = `<button class="control-button success" onclick="showReservationModal()">
                        <i class="fas fa-handshake"></i>
                        <span>Reservar Lote</span>
                    </button>`;
            }

            lotDataContent.innerHTML = `
                <div class="lot-data-grid">
                    <div class="lot-data-item">
                        <span class="lot-data-label">Área:</span>
                        <span class="lot-data-value">${lote.area.toFixed(2)} m²</span>
                    </div>
                    <div class="lot-data-item">
                        <span class="lot-data-label">Perímetro:</span>
                        <span class="lot-data-value">${perimeter.toFixed(2)} ml</span>
                    </div>
                    <div class="lot-data-item">
                        <span class="lot-data-label">Nro. Lote:</span>
                        <span class="lot-data-value">${lote.name.replace('LOTE ', '')}</span>
                    </div>
                    <div class="lot-data-item">
                        <span class="lot-data-label">Manzano:</span>
                        <span class="lot-data-value">${lote.manzano.replace('MZNO ', '')}</span>
                    </div>
                    <div class="lot-data-item">
                        <span class="lot-data-label">Estado:</span>
                        <span class="lot-data-value" style="color: ${statusColor};">${statusText}</span>
                    </div>
                    <div class="lot-data-item">
                        <span class="lot-data-label">Precio:</span>
                        <span class="lot-data-value">$${lote.price.toFixed(2)}</span>
                    </div>
                </div>
                ${actionButton}
                ${lote.price ? `<div class="price-tag">$${lote.price.toFixed(2)} USD</div>` : ''}
            `;

            drawLoteInCanvas(lote);
        }

        function drawLoteInCanvas(lote) {
            const canvas = document.getElementById('lot-plan-canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const latlngs = lote.polygon.getLatLngs()[0];

            let minLat = latlngs[0].lat, maxLat = latlngs[0].lat;
            let minLng = latlngs[0].lng, maxLng = latlngs[0].lng;

            latlngs.forEach(point => {
                minLat = Math.min(minLat, point.lat);
                maxLat = Math.max(maxLat, point.lat);
                minLng = Math.min(minLng, point.lng);
                maxLng = Math.max(maxLng, point.lng);
            });

            const margin = 15;
            const width = canvas.width - 2 * margin;
            const height = canvas.height - 2 * margin;

            const latRange = maxLat - minLat;
            const lngRange = maxLng - minLng;

            let scale, offsetX = 0, offsetY = 0;
            const canvasAspect = width / height;
            const geoAspect = lngRange / latRange;

            if (geoAspect > canvasAspect) {
                scale = width / lngRange;
                offsetY = (height - (latRange * scale)) / 2;
            } else {
                scale = height / latRange;
                offsetX = (width - (lngRange * scale)) / 2;
            }

            const points = latlngs.map(point => {
                const x = margin + offsetX + ((point.lng - minLng) * scale);
                const y = margin + offsetY + ((maxLat - point.lat) * scale);
                return { x, y };
            });

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);

            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }

            ctx.closePath();

            let fillColor = 'rgba(139, 69, 19, 0.2)';
            switch (lote.status) {
                case 'available':
                    fillColor = 'rgba(16, 185, 129, 0.2)';
                    break;
                case 'reserved':
                    fillColor = 'rgba(245, 158, 11, 0.2)';
                    break;
                case 'sold':
                    fillColor = 'rgba(239, 68, 68, 0.2)';
                    break;
            }

            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            ctx.stroke();

            const individualSegments = [];
            for (let i = 0; i < latlngs.length; i++) {
                const nextIndex = (i + 1) % latlngs.length;
                const distance = latlngs[i].distanceTo(latlngs[nextIndex]);
                const isCurve = lote.bulges && lote.bulges[i] && Math.abs(lote.bulges[i]) > 0.0001;

                individualSegments.push({
                    index: i,
                    distance: distance,
                    isCurve: isCurve
                });
            }

            const SIZE_TOLERANCE = 0.15;
            const MIN_SEGMENTS_TO_GROUP = 3;
            const LARGE_THRESHOLD = 5;

            const groupedSegments = [];
            let i = 0;

            while (i < individualSegments.length) {
                const currentSeg = individualSegments[i];

                if (currentSeg.distance >= LARGE_THRESHOLD) {
                    groupedSegments.push({
                        type: 'individual',
                        startIndex: i,
                        endIndex: i,
                        segments: [currentSeg],
                        totalDistance: currentSeg.distance,
                        count: 1
                    });
                    i++;
                    continue;
                }

                const similarSegments = [currentSeg];
                let j = i + 1;

                while (j < individualSegments.length) {
                    const nextSeg = individualSegments[j];

                    if (nextSeg.distance >= LARGE_THRESHOLD) {
                        break;
                    }

                    const avgDistance = (currentSeg.distance + nextSeg.distance) / 2;
                    const difference = Math.abs(currentSeg.distance - nextSeg.distance);
                    const percentDiff = difference / avgDistance;

                    if (percentDiff <= SIZE_TOLERANCE) {
                        similarSegments.push(nextSeg);
                        j++;
                    } else {
                        break;
                    }
                }

                if (similarSegments.length >= MIN_SEGMENTS_TO_GROUP) {
                    const totalDist = similarSegments.reduce((sum, seg) => sum + seg.distance, 0);
                    groupedSegments.push({
                        type: 'grouped',
                        startIndex: i,
                        endIndex: j - 1,
                        segments: similarSegments,
                        totalDistance: totalDist,
                        count: similarSegments.length,
                        avgSegmentSize: totalDist / similarSegments.length
                    });
                    i = j;
                } else {
                    groupedSegments.push({
                        type: 'individual',
                        startIndex: i,
                        endIndex: i,
                        segments: [currentSeg],
                        totalDistance: currentSeg.distance,
                        count: 1
                    });
                    i++;
                }
            }

            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 1;
            ctx.font = 'bold 9px Arial';
            ctx.fillStyle = '#2c3e50';

            for (let i = 0; i < latlngs.length; i++) {
                const nextIndex = (i + 1) % latlngs.length;
                const p1 = points[i];
                const p2 = points[nextIndex];

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }

            groupedSegments.forEach(group => {
                if (group.type === 'individual') {
                    const i = group.startIndex;
                    const nextIndex = (i + 1) % latlngs.length;
                    const p1 = points[i];
                    const p2 = points[nextIndex];

                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;

                    ctx.save();
                    ctx.translate(midX, midY);

                    const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                    ctx.rotate(angle);

                    const dimensionText = `${group.totalDistance.toFixed(2)}m`;
                    const textWidth = ctx.measureText(dimensionText).width;

                    if (Math.abs(angle) > Math.PI / 2) {
                        ctx.rotate(Math.PI);
                        ctx.fillText(dimensionText, -textWidth / 2, -3);
                    } else {
                        ctx.fillText(dimensionText, -textWidth / 2, -3);
                    }

                    ctx.restore();

                } else if (group.type === 'grouped') {
                    const startIdx = group.startIndex;
                    const endIdx = (group.endIndex + 1) % latlngs.length;

                    const p1 = points[startIdx];
                    const p2 = points[endIdx];

                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const length = Math.sqrt(dx * dx + dy * dy);

                    const perpX = -dy / length;
                    const perpY = dx / length;

                    const offsetDistance = 15;
                    const labelX = midX + perpX * offsetDistance;
                    const labelY = midY + perpY * offsetDistance;

                    ctx.save();
                    ctx.translate(labelX, labelY);

                    const angle = Math.atan2(dy, dx);
                    ctx.rotate(angle);

                    const dimensionText = `${group.totalDistance.toFixed(2)}m`;
                    const textWidth = ctx.measureText(dimensionText).width;

                    if (Math.abs(angle) > Math.PI / 2) {
                        ctx.rotate(Math.PI);
                        ctx.fillText(dimensionText, -textWidth / 2, -3);
                    } else {
                        ctx.fillText(dimensionText, -textWidth / 2, -3);
                    }

                    ctx.restore();
                }
            });

            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';

            let area = 0;
            let centroidX = 0;
            let centroidY = 0;

            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                const crossProduct = points[i].x * points[j].y - points[j].x * points[i].y;
                area += crossProduct;
                centroidX += (points[i].x + points[j].x) * crossProduct;
                centroidY += (points[i].y + points[j].y) * crossProduct;
            }

            area *= 0.5;
            centroidX /= (6 * area);
            centroidY /= (6 * area);

            if (centroidX < margin || centroidX > canvas.width - margin ||
                centroidY < margin || centroidY > canvas.height - margin) {
                centroidX = 0;
                centroidY = 0;
                points.forEach(point => {
                    centroidX += point.x;
                    centroidY += point.y;
                });
                centroidX /= points.length;
                centroidY /= points.length;
            }

            const loteNumber = lote.loteNumero || lote.name.replace(/\D+/g, '');

            const circleRadius = 18;
            ctx.fillStyle = '#4285F4';
            ctx.beginPath();
            ctx.arc(centroidX, centroidY, circleRadius, 0, 2 * Math.PI);
            ctx.fill();

            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(loteNumber, centroidX, centroidY);
            ctx.textAlign = 'start';
            ctx.textBaseline = 'alphabetic';
        }

        function calculateArea(latlngs) {
            let area = 0;
            const R = 6371000;

            for (let i = 0; i < latlngs.length; i++) {
                const p1 = latlngs[i];
                const p2 = latlngs[(i + 1) % latlngs.length];

                const lat1 = p1.lat * Math.PI / 180;
                const lat2 = p2.lat * Math.PI / 180;
                const lng1 = p1.lng * Math.PI / 180;
                const lng2 = p2.lng * Math.PI / 180;

                area += (lng2 - lng1) * (2 + Math.sin(lat1) + Math.sin(lat2));
            }

            return Math.abs(area * R * R / 2);
        }

        function calculatePerimeter(latlngs) {
            let perimeter = 0;

            for (let i = 0; i < latlngs.length; i++) {
                const p1 = latlngs[i];
                const p2 = latlngs[(i + 1) % latlngs.length];

                perimeter += p1.distanceTo(p2);
            }

            return perimeter;
        }

        function createExpandedVertices(vertices, bulges) {
            if (!vertices || vertices.length === 0) return [];

            const expandedVertices = [];
            const segments = 32;

            for (let i = 0; i < vertices.length; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertices.length];
                const bulge = bulges[i] || 0;

                expandedVertices.push(v1);

                if (Math.abs(bulge) > 0.0001) {
                    const includedAngle = 4 * Math.atan(bulge);
                    const dx = v2.x - v1.x;
                    const dy = v2.y - v1.y;
                    const chordLength = Math.sqrt(dx * dx + dy * dy);

                    if (chordLength > 0.0001) {
                        const radius = chordLength / (2 * Math.sin(includedAngle / 2));
                        const chordAngle = Math.atan2(dy, dx);
                        const centerAngle = (Math.PI / 2 - includedAngle / 2) + chordAngle;
                        const centerX = v1.x + radius * Math.cos(centerAngle);
                        const centerY = v1.y + radius * Math.sin(centerAngle);

                        let startAngle = Math.atan2(v1.y - centerY, v1.x - centerX);
                        let endAngle = Math.atan2(v2.y - centerY, v2.x - centerX);

                        if (bulge > 0) {
                            if (endAngle <= startAngle) endAngle += 2 * Math.PI;
                        } else {
                            if (startAngle <= endAngle) startAngle += 2 * Math.PI;
                            [startAngle, endAngle] = [endAngle, startAngle];
                        }

                        const angleStep = (endAngle - startAngle) / segments;

                        for (let j = 1; j < segments; j++) {
                            const angle = startAngle + angleStep * j;
                            const x = centerX + Math.abs(radius) * Math.cos(angle);
                            const y = centerY + Math.abs(radius) * Math.sin(angle);
                            expandedVertices.push({ x: x, y: y });
                        }
                    }
                }
            }

            return expandedVertices;
        }

        function calculateAreaDXF(vertices, bulges) {
            if (!vertices || vertices.length < 3) return 0;

            let area = 0;

            for (let i = 0; i < vertices.length; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertices.length];

                area += (v1.x * v2.y - v2.x * v1.y);
            }

            return Math.abs(area / 2);
        }

        function clearView() {
            dxfLayer.clearLayers();
            lotesLayer.clearLayers();
            manzanosLayer.clearLayers();

            manzanosData = {};
            lotesData = {};
            selectedLote = null;
            allBounds = null;

            document.getElementById('lot-data-content').innerHTML = `
                <div class="empty-lote-data">
                    <i class="fas fa-mouse-pointer"></i>
                    Selecciona un lote para ver sus datos
                </div>
            `;

            const canvas = document.getElementById('lot-plan-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            updateManzanosList();
            updateLotesList();
            updateStatistics();

            showNotification('Vista limpiada correctamente', 'info');
        }

        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            const messageElement = notification.querySelector('.notification-message');
            const iconElement = notification.querySelector('.notification-icon i');

            messageElement.textContent = message;

            notification.className = 'notification ' + type;

            if (type === 'success') {
                iconElement.className = 'fas fa-check-circle';
            } else if (type === 'error') {
                iconElement.className = 'fas fa-exclamation-circle';
            } else {
                iconElement.className = 'fas fa-info-circle';
            }

            notification.classList.add('show');

            setTimeout(() => {
                hideNotification();
            }, 5000);
        }

        function hideNotification() {
            const notification = document.getElementById('notification');
            notification.classList.remove('show');
        }

        function convertDXFToLatLng(vertex, coordSystem, utmZone, hemisphere, refLat, refLng, scale) {
            const x = vertex.x || 0, y = vertex.y || 0;

            if (coordSystem === 'utm') {
                try {
                    const utmProj = hemisphere === 'south'
                        ? `+proj=utm +zone=${utmZone} +south +datum=WGS84 +units=m +no_defs`
                        : `+proj=utm +zone=${utmZone} +datum=WGS84 +units=m +no_defs`;
                    const wgs84 = '+proj=longlat +datum=WGS84 +no_defs';
                    const result = proj4(utmProj, wgs84, [x, y]);
                    return [result[1], result[0]];
                } catch (error) {
                    console.error('Error en conversión UTM:', error);
                    if (Math.abs(x) > 1000 || Math.abs(y) > 1000) {
                        const adjustedX = x - 500000;
                        const lat = y / 111320;
                        const lng = (adjustedX / (111320 * Math.cos(lat * Math.PI / 180)));
                        return [lat, lng - 66];
                    } else {
                        return [refLat + (y * scale), refLng + (x * scale)];
                    }
                }
            } else {
                if (Math.abs(x) <= 180 && Math.abs(y) <= 90) {
                    return [y, x];
                } else if (Math.abs(x) > 1 && Math.abs(y) > 1) {
                    const lat = y / 111320;
                    const lng = x / (111320 * Math.cos(lat * Math.PI / 180));
                    return [lat, lng];
                } else {
                    return [refLat + (y * scale), refLng + (x * scale)];
                }
            }
        }

        function getColorFromDXF(colorIndex) {
            const colors = {
                1: '#FF0000', 2: '#FFFF00', 3: '#00FF00', 4: '#00FFFF', 5: '#0000FF',
                6: '#FF00FF', 7: '#000000', 8: '#808080', 9: '#C0C0C0', 10: '#FF0000',
                30: '#FF7F00', 40: '#FF7F7F', 50: '#7F0000', 60: '#7F3F00', 70: '#7F7F00',
                80: '#00FF00', 90: '#007F00', 100: '#007F7F', 110: '#00FF7F', 120: '#00FFFF',
                130: '#007FFF', 140: '#0000FF', 150: '#7F00FF', 160: '#FF00FF', 170: '#FF007F',
                180: '#7F007F', 250: '#3F3F3F', 255: '#FFFFFF'
            };
            return colors[colorIndex] || '#000000';
        }

        function getLineWeightInPixels(lineweight) {
            if (!lineweight || lineweight === -1 || lineweight === -2) return 2;
            const mmValue = Math.abs(lineweight) / 100;
            return Math.max(1, Math.min(mmValue * 3, 10));
        }

        function createBulgeArc(v1, v2, bulge, coordSystem, utmZone, hemisphere, refLat, refLng, scale, segments = 64) {
            const points = [];
            if (Math.abs(bulge) < 0.00001) return points;

            const includedAngle = 4 * Math.atan(bulge);
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            const chordLength = Math.sqrt(dx * dx + dy * dy);

            if (chordLength < 0.0001) return points;

            const radius = chordLength / (2 * Math.sin(includedAngle / 2));
            const chordAngle = Math.atan2(dy, dx);
            const centerAngle = (Math.PI / 2 - includedAngle / 2) + chordAngle;
            const centerX = v1.x + radius * Math.cos(centerAngle);
            const centerY = v1.y + radius * Math.sin(centerAngle);

            let startAngle = Math.atan2(v1.y - centerY, v1.x - centerX);
            let endAngle = Math.atan2(v2.y - centerY, v2.x - centerX);

            if (bulge > 0) {
                if (endAngle <= startAngle) endAngle += 2 * Math.PI;
            } else {
                if (startAngle <= endAngle) startAngle += 2 * Math.PI;
                [startAngle, endAngle] = [endAngle, startAngle];
            }

            const angleStep = (endAngle - startAngle) / segments;

            for (let i = 1; i < segments; i++) {
                const angle = startAngle + angleStep * i;
                const x = centerX + Math.abs(radius) * Math.cos(angle);
                const y = centerY + Math.abs(radius) * Math.sin(angle);
                points.push(convertDXFToLatLng({ x, y }, coordSystem, utmZone, hemisphere, refLat, refLng, scale));
            }

            return points;
        }
    </script>
</body>

</html>